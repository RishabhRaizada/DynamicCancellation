import sys
import json
import requests
from azure.ai.projects import AIProjectClient
from azure.identity import DefaultAzureCredential
from azure.ai.agents.models import ListSortOrder


PROJECT_ENDPOINT = "https://testapiagent-resource.services.ai.azure.com/api/projects/testapiagent"
AGENT_ID = "asst_fVKKUVovJ6FGONPYJOV3pe21"

MCP_URL = "http://127.0.0.1:8003/mcp"


def execute_mcp_tool(tool_name: str, arguments: dict):
    print(f"ðŸ”® Executing {tool_name} via MCP")
    print(f"ðŸ“ Arguments: {arguments}")

    payload = {
        "jsonrpc": "2.0",
        "method": "tools/call",
        "params": {
            "name": tool_name,
            "arguments": arguments
        },
        "id": 1
    }

    headers = {
        "Accept": "application/json, text/event-stream",
        "Content-Type": "application/json"
    }

    response = requests.post(MCP_URL, json=payload, headers=headers, timeout=30)

    if response.status_code != 200:
        raise RuntimeError(f"MCP call failed: {response.status_code} {response.text}")


    for line in response.text.splitlines():
        if not line.startswith("data:"):
            continue

        raw = line.replace("data:", "", 1).strip()
        mcp_payload = json.loads(raw)

        result = mcp_payload.get("result", {})

        structured = result.get("structuredContent", {})
        content = structured.get("content", [])

        if content and content[0].get("type") == "json":
            print("âœ… MCP JSON received (structuredContent)")
            return content[0]["json"]

        # ðŸ”„ Fallback: content[].text contains JSON string
        for item in result.get("content", []):
            if item.get("type") == "text":
                try:
                    embedded = json.loads(item["text"])
                    for c in embedded.get("content", []):
                        if c.get("type") == "json":
                            print("âœ… MCP JSON received (embedded text)")
                            return c["json"]
                except Exception:
                    pass

    # âŒ If we reach here, parsing failed
    raise RuntimeError("No MCP JSON response found in SSE stream")

# ==============================
# AGENT RUNNER
# ==============================

def run_agent(pnr: str, last_name: str):
    print("\nðŸš€ Running manual MCP + Agent reasoning")
    print(f"PNR: {pnr}, LAST NAME: {last_name}")

    # ==============================
    # 1ï¸âƒ£ CALL MCP
    # ==============================
    mcp_data = execute_mcp_tool(
        "recover_passenger",
        {"pnr": pnr, "last_name": last_name}
    )

    print("\nðŸ“¦ MCP RESPONSE:")
    print(json.dumps(mcp_data, indent=2))

    # ==============================
    # 2ï¸âƒ£ HARD STOP IF NOT ELIGIBLE
    # ==============================
    status = mcp_data.get("status")

    if status != "success":
        print("\nâ›” RECOVERY FLOW STOPPED")
        print(json.dumps({
            "status": status,
            "reason": mcp_data.get("reason"),
            "message": "Passenger not eligible for auto-recovery. Agent NOT invoked."
        }, indent=2))
        return  # ðŸš¨ ABSOLUTE STOP â€” AGENT WILL NEVER RUN

    # ==============================
    # 3ï¸âƒ£ SAFETY CHECK (DEFENSIVE)
    # ==============================
    recovery = mcp_data.get("recovery", {})
    if not recovery.get("available_flights") or not recovery.get("available_seats"):
        print("\nâ›” INCOMPLETE RECOVERY CONTEXT")
        print("Flights or seats missing â€” agent invocation blocked.")
        return

    # ==============================
    # 4ï¸âƒ£ AGENT INVOCATION (SUCCESS ONLY)
    # ==============================
    client = AIProjectClient(
        endpoint=PROJECT_ENDPOINT,
        credential=DefaultAzureCredential()
    )

    with client:
        thread = client.agents.threads.create()

        client.agents.messages.create(
            thread_id=thread.id,
            role="user",
            content=f"""
You are a STRICT Flight & Seat Recovery Decision Engine.
Passenger Profile:
--------------------------------
INPUT DATA (ACTUAL MCP RESPONSE - THIS IS YOUR UNIVERSE)
--------------------------------

Passenger Profile:
{json.dumps(mcp_data.get('passenger', {}), indent=2)}

Original Flight:
{json.dumps(mcp_data.get('original_flight', {}), indent=2)}

Available Flights (YOU MUST SELECT FROM THIS LIST):
{json.dumps(recovery.get('available_flights', []), indent=2)}

Available Seats (YOU MUST SELECT FROM THIS LIST):
{json.dumps(recovery.get('available_seats', []), indent=2)}

You are given a JSON object that contains:
- passenger profile (CDP)
- original flight
- available_flights (array)
- available_seats (array)

YOU MUST ALWAYS RETURN A DECISION IF status == "success".

==============================
ABSOLUTE SAFETY RULES
==============================

1. You MUST ONLY select flights from recovery.available_flights.
2. You MUST ONLY select seats from recovery.available_seats.
3. You MUST NOT invent any flight, seat, price, airport, or identifier.
4. If recovery.available_flights.length == 0 OR recovery.available_seats.length == 0:
   - Return {{}} ONLY in this case.

==============================
SEATâ€“FLIGHT RELATIONSHIP
==============================

- available_seats are NOT flight-specific.
- Seats belong to the aircraft, not to a flight_uid.
- Select the flight FIRST.
- Then select the best seat from available_seats.
- Do NOT attempt to match seat to flight_uid.

==============================
CDP PRIORITY (HIGHEST FIRST)
==============================

Read booking_details[0].

PRIORITY 1 (OVERRIDES ALL):
- If STUDENT > 0:
  - Choose the flight with LOWEST min_economy_fare.
  - Ignore comfort, stretch, timing unless prices are equal.
  - Choose an ECONOMY seat.
  - Prefer highest availability seat.
- If HIGHSPENDERHIGHFREQ == true OR HIGHSPENDERLOWFREQ == true:
  - Ignore price.
  - Prefer comfort, stretch, business class, legroom.

PRIORITY 2 (ONLY IF NOT STUDENT/HIGHSPENDER):
- BUSINESS > LEISURE â†’ time + comfort
- LEISURE â‰¥ BUSINESS â†’ price + flexibility

==============================
FLIGHT SELECTION LOGIC
==============================

If available_flights.length == 1:
- Select that flight immediately.

Otherwise:
- Rank flights using:
  + NonStop
  + Earlier utcArrival
  + Closer utcDeparture to original flight
  - fillingFast penalty

==============================
SEAT SELECTION LOGIC (STRICT)
==============================

STUDENT OVERRIDE (HIGHEST PRIORITY â€” HARD RULE):

If booking_details[0].STUDENT > 0:

- You MUST select travel_class == "Y"
- Selecting travel_class == "C" is STRICTLY FORBIDDEN
- If selected_seat.travel_class != "Y":
  â†’ THIS IS A FAILURE

Seat ranking for STUDENT:
1. Highest availability
2. Ignore LEGROOM, XL, AISLE, WINDOW
3. Ignore comfort completely

You MUST explicitly verify:
selected_seat.travel_class == "Y"
before returning output.

If HIGHSPENDER:
- travel_class == "C"
- Prefer LEGROOM, XL, AISLE/WINDOW

==============================
OUTPUT (MANDATORY)
==============================

You MUST return this structure:

{{
  "selected_flight": {{ ... }},
  "selected_seat": {{ ... }},
  "reasoning": {{
    "flight_reason": "...",
    "seat_reason": "..."
  }}
}}

You are NOT allowed to return {{}} if flights and seats exist.
You are NOT allowed to invent data.
You are NOT allowed to omit fields.

"""
        )

        run = client.agents.runs.create(
            thread_id=thread.id,
            agent_id=AGENT_ID
        )

        while True:
            run = client.agents.runs.get(thread.id, run.id)
            if run.status == "completed":
                break

        messages = client.agents.messages.list(
            thread_id=thread.id,
            order=ListSortOrder.ASCENDING
        )

        print("\nðŸŽ¯ FINAL AGENT OUTPUT:")
        for msg in reversed(list(messages)):
            if msg.role == "assistant":
                print(msg.text_messages[0].text.value)
                break

# ==============================
# ENTRY
# ==============================
/Users/rishabhraizada/Desktop/AIonOS Uniform/Dashboard UI - MCP/data/cancell_trigger.json
if __name__ == "__main__":
    if len(sys.argv) != 3:
        print("Usage: python testing.py <PNR> <LAST_NAME>")
        sys.exit(1)

    run_agent(sys.argv[1], sys.argv[2])
